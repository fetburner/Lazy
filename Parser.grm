fun SyntaxIF EXP1 EXP2 EXP3 =
  Syntax.CASE
    (EXP1,
      [(Syntax.PCONS (Cons.BOOL true, []), EXP2),
       (Syntax.PCONS (Cons.BOOL false, []), EXP3)])
%%
(* Declarations for ML-Yacc *)

%name Lazy
%pos unit
%eop SEMICOLON
%start TOPLEVEL

(* Terminal symbols *)
%term IDENT of string (* value identifier *)
    | BOOL of bool
    | DIGIT of int
    | CASE (* case *)
    | ELSE (* else *)
    | END (* end *)
    | FN (* fn *)
    | IF (* if *)
    | IN (* in *)
    | LET (* let *)
    | OF (* of *)
    | REC (* rec *)
    | THEN (* then *)
    | VAL (* val *)
    | EQUAL (* = *)
    | COMMA (* , *)
    | LPAREN (* ( *)
    | RPAREN (* ) *)
    | FATARROW (* => *)
    | SEMICOLON (* ; *)
    | PLUS (* + *)
    | MINUS (* - *)
    | TIMES (* * *)
    | LE (* <= *)
    | LBRACKET (* [ *)
    | RBRACKET (* * *)
    | CONS (* :: *)
    | BAR (* | *)
    | AND (* and *)
    | UNDERSCORE (* _ *)
    | ANDALSO (* ANDALSO *)
    | ORELSE (* ORELSE *)

(* Nonterminal symbols *)
%nonterm ATEXP of Syntax.exp
       | EXP of Syntax.exp
       | APPEXP of Syntax.exp
       | PRODEXP of Syntax.exp
       | SUMEXP of Syntax.exp
       | CONSEXP of Syntax.exp
       | CMPEXP of Syntax.exp
       | ANDEXP of Syntax.exp
       | OREXP of Syntax.exp
       | ATDEC of Syntax.dec
       | VALBIND of (string * Syntax.exp) list
       | DEC of Syntax.dec list
       | TUPLE_BODY of Syntax.exp list
       | PATROW of (Syntax.pat * Syntax.exp) list
       | ATPAT of Syntax.pat
       | PAT of Syntax.pat
       | PTUPLE_BODY of Syntax.pat list
       | TOPLEVEL of Syntax.dec

%%

(* Production rules *)
ATEXP : BOOL
          (Syntax.CONS (Cons.BOOL BOOL, []))
      | DIGIT
          (Syntax.CONS (Cons.INT DIGIT, []))
      | LPAREN RPAREN
          (Syntax.CONS (Cons.TUPLE [], []))
      | LBRACKET RBRACKET
          (Syntax.CONS (Cons.NIL (Type.genvar (valOf Int.maxInt)), []))
      | LPAREN TUPLE_BODY RPAREN
          (Syntax.CONS
            (Cons.TUPLE
              (List.tabulate
                (length TUPLE_BODY,
                 fn _ => Type.genvar (valOf Int.maxInt))),
             TUPLE_BODY))
      | IDENT
          (Syntax.VAR IDENT)
      | LET DEC IN EXP END
          (Syntax.LET (DEC, EXP))
      | LPAREN EXP RPAREN
          (EXP)

APPEXP : ATEXP
           (ATEXP)
       | APPEXP ATEXP
           (Syntax.APP (APPEXP, ATEXP))

PRODEXP : APPEXP
            (APPEXP)
        | PRODEXP TIMES APPEXP
            (Syntax.PRIM (Prim.TIMES, [PRODEXP, APPEXP]))

SUMEXP : PRODEXP
           (PRODEXP)
       | SUMEXP PLUS PRODEXP
           (Syntax.PRIM (Prim.PLUS, [SUMEXP, PRODEXP]))
       | SUMEXP MINUS PRODEXP
           (Syntax.PRIM (Prim.MINUS, [SUMEXP, PRODEXP]))

CONSEXP : SUMEXP
            (SUMEXP)
        | SUMEXP CONS CONSEXP
            (Syntax.CONS (Cons.CONS (Type.genvar (valOf Int.maxInt)), [SUMEXP, CONSEXP]))

CMPEXP : CONSEXP
           (CONSEXP)
       | CONSEXP LE CONSEXP
           (Syntax.PRIM (Prim.LE, [CONSEXP1, CONSEXP2]))

ANDEXP : CMPEXP
           (CMPEXP)
       | CMPEXP ANDALSO ANDEXP
           (SyntaxIF CMPEXP ANDEXP (Syntax.CONS (Cons.BOOL false, [])))

OREXP : ANDEXP
          (ANDEXP)
      | ANDEXP ORELSE OREXP
          (SyntaxIF ANDEXP (Syntax.CONS (Cons.BOOL true, [])) OREXP)

EXP : OREXP
        (OREXP)
    | FN IDENT FATARROW EXP
        (Syntax.ABS (IDENT, EXP))
    | IF EXP THEN EXP ELSE EXP
        (SyntaxIF EXP1 EXP2 EXP3)
    | CASE EXP OF PATROW
        (Syntax.CASE (EXP, PATROW))

ATDEC : VAL IDENT EQUAL EXP
          (Syntax.VAL (IDENT, EXP))
      | VAL REC VALBIND
          (Syntax.VALREC (VALBIND))

VALBIND : IDENT EQUAL EXP
            ([(IDENT, EXP)])
        | IDENT EQUAL EXP AND VALBIND
            ((IDENT, EXP) :: VALBIND)

DEC : ATDEC
        ([ATDEC])
    | ATDEC SEMICOLON DEC
        (ATDEC :: DEC)
    | ATDEC DEC
        (ATDEC :: DEC)

TUPLE_BODY : EXP COMMA EXP
               ([EXP1, EXP2])
           | EXP COMMA TUPLE_BODY
               (EXP :: TUPLE_BODY)

PATROW : PAT FATARROW EXP
           ([(PAT, EXP)])
       | PAT FATARROW EXP BAR PATROW
           ((PAT, EXP) :: PATROW)

ATPAT : BOOL
          (Syntax.PCONS (Cons.BOOL BOOL, []))
      | DIGIT
          (Syntax.PCONS (Cons.INT DIGIT, []))
      | IDENT
          (Syntax.PVAR IDENT)
      | UNDERSCORE
          (Syntax.PWILD)
      | LBRACKET RBRACKET
          (Syntax.PCONS (Cons.NIL (Type.genvar (valOf Int.maxInt)), []))
      | LPAREN RPAREN
          (Syntax.PCONS (Cons.TUPLE [], []))
      | LPAREN PTUPLE_BODY RPAREN
          (Syntax.PCONS
            (Cons.TUPLE
              (List.tabulate
                (length PTUPLE_BODY,
                 fn _ => Type.genvar (valOf Int.maxInt))),
             PTUPLE_BODY))
      | LPAREN PAT RPAREN
          (PAT)

PAT : ATPAT
        (ATPAT)
    | ATPAT CONS PAT
        (Syntax.PCONS (Cons.CONS (Type.genvar (valOf Int.maxInt)), [ATPAT, PAT]))

PTUPLE_BODY : PAT COMMA PAT
                ([PAT1, PAT2])
            | PAT COMMA PTUPLE_BODY
                (PAT :: PTUPLE_BODY)

TOPLEVEL : EXP
             (Syntax.VAL ("it", EXP))
         | ATDEC
             (ATDEC)
